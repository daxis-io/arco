// proto/arco/v1/event.proto
syntax = "proto3";
package arco.v1;

option java_multiple_files = true;
option java_package = "com.arco.v1";
option go_package = "github.com/daxis-io/arco/proto/arco/v1";

import "google/protobuf/timestamp.proto";
import "arco/v1/common.proto";

// Event envelope for all catalog events (Tier 2 append-only log)
//
// Ordering semantics:
// - event_id is a ULID providing time-ordered lexicographic sorting
// - Compactors use event_id as the watermark cursor (no coordination required)
// - Readers paginate using event_id as cursor (lexical comparison)
// - Deduplication uses idempotency_key within a time window
//
// Clock skew and late-event handling:
//
// ULID timestamps embed the local clock time, so clock skew between writers
// can cause events to appear out-of-order when merged. The system handles this:
//
// 1. **Bounded skew assumption**: Writers are expected to have NTP-synced clocks.
//    Skew beyond a few seconds indicates misconfigured infrastructure.
//
// 2. **Watermark lag**: Compactors wait (e.g., 1 minute) before processing events
//    to allow late-arriving events to settle. The watermark is always the oldest
//    unprocessed event_id minus the lag window.
//
// 3. **Idempotency**: The idempotency_key field allows late events to be
//    deduplicated if they arrive after the original was already processed.
//    Compactors maintain a sliding window of processed idempotency keys.
//
// 4. **At-least-once delivery**: Events may be written multiple times (retries).
//    Readers must handle duplicates via idempotency_key.
//
// 5. **No reordering guarantee**: Within the watermark lag window, events may
//    appear in any order. Business logic must be tolerant of this (e.g., use
//    last-write-wins with timestamp tiebreaker for conflicting updates).
//
// For strict ordering requirements, use Tier 1 (CAS-based) operations instead.
message CatalogEvent {
  // Unique event ID (ULID for ordering)
  //
  // ULID provides:
  // - Lexicographically sortable (natural ordering without coordination)
  // - Millisecond timestamp prefix (approximate time ordering)
  // - 80 bits of randomness (collision resistance)
  //
  // Clock skew note: ULID timestamps come from the writer's local clock.
  // Events from different writers may interleave unexpectedly if clocks differ.
  // See message-level comments for handling strategies.
  //
  // This is the cursor for watermarking and pagination.
  string event_id = 1;

  // Event type discriminator
  string event_type = 2;

  // Schema version for forward compatibility
  uint32 event_version = 3;

  // Event timestamp (server-side)
  google.protobuf.Timestamp timestamp = 4;

  // Event source (e.g., "servo", "ui", "profiler")
  string source = 5;

  // Tenant context
  TenantId tenant_id = 6;

  // Workspace context (tenant + workspace = primary scope)
  WorkspaceId workspace_id = 7;

  // Idempotency key (for deduplication)
  string idempotency_key = 8;

  // Reserved: was numeric position (removed - use event_id for cursors)
  // Using ULID event_id avoids coordination and works with multi-writer append.
  reserved 9;
  reserved "position";

  // Event payload (one of)
  oneof payload {
    AssetCreated asset_created = 20;
    AssetUpdated asset_updated = 21;
    MaterializationCompleted materialization_completed = 22;
    LineageRecorded lineage_recorded = 23;
  }
}

// Asset creation event
message AssetCreated {
  AssetId asset_id = 1;
  AssetKey asset_key = 2;
  string location = 3;
  AssetFormat format = 4;
  string description = 5;
  repeated string owners = 6;
}

// Asset update event
message AssetUpdated {
  AssetId asset_id = 1;
  // Fields that changed (sparse update)
  optional string location = 2;
  optional string description = 3;
  repeated string owners = 4;
}

// Materialization completion event (high-frequency, Tier 2)
message MaterializationCompleted {
  MaterializationId materialization_id = 1;
  AssetId asset_id = 2;
  PartitionKey partition_key = 3;
  RunId run_id = 4;
  TaskId task_id = 5;

  // Output files
  repeated FileEntry files = 6;

  // Statistics
  int64 row_count = 7;
  int64 byte_size = 8;
  string schema_hash = 9;

  // Timing
  google.protobuf.Timestamp started_at = 10;
  google.protobuf.Timestamp completed_at = 11;
}

// FileEntry is now defined in common.proto

// Lineage recording event
message LineageRecorded {
  RunId run_id = 1;
  repeated LineageEdge edges = 2;
}

// Single lineage edge (source -> target dependency)
message LineageEdge {
  AssetId source_asset_id = 1;
  AssetId target_asset_id = 2;
  repeated PartitionId source_partitions = 3;
  repeated PartitionId target_partitions = 4;

  // Hash of dependency specification for change detection
  string dependency_fingerprint = 5;
}
