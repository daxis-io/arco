//! Automation event types for schedules and sensors.
//!
//! These events are emitted by automation controllers (`ScheduleController`, `SensorController`)
//! and folded by the compactor to update projections.

use serde::{Deserialize, Serialize};

/// Status of a schedule tick evaluation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(tag = "status", rename_all = "snake_case")]
pub enum TickStatus {
    /// Tick triggered a run.
    Triggered,
    /// Tick was skipped (e.g., paused, condition not met).
    Skipped {
        /// Reason the tick was skipped.
        reason: String,
    },
    /// Tick evaluation failed.
    Failed {
        /// Error message describing the failure.
        error: String,
    },
}

/// Trigger source for sensor evaluations.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(tag = "source", rename_all = "snake_case")]
pub enum TriggerSource {
    /// Push sensor triggered by Pub/Sub message.
    Push {
        /// Pub/Sub message ID for idempotency.
        message_id: String,
    },
    /// Poll sensor triggered by timer.
    Poll {
        /// Epoch timestamp of the poll timer.
        poll_epoch: i64,
    },
}

/// Status of a sensor evaluation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(tag = "status", rename_all = "snake_case")]
pub enum SensorEvalStatus {
    /// Sensor triggered one or more runs.
    Triggered,
    /// Sensor evaluated but no new data found.
    NoNewData,
    /// Sensor evaluation failed.
    Error {
        /// Error message describing the failure.
        message: String,
    },
    /// Sensor evaluation was skipped due to stale cursor (CAS failed).
    SkippedStaleCursor,
}

/// A run request generated by a sensor evaluation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct RunRequest {
    /// Stable run key for idempotency.
    pub run_key: String,
    /// Fingerprint of the request payload for conflict detection.
    pub request_fingerprint: String,
    /// Assets to materialize.
    pub asset_selection: Vec<String>,
    /// Optional partition selection.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition_selection: Option<Vec<String>>,
}

/// Reference to the source that triggered a run request.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum SourceRef {
    /// Triggered by a schedule tick.
    Schedule {
        /// Schedule identifier (ULID).
        schedule_id: String,
        /// Tick identifier.
        tick_id: String,
    },
    /// Triggered by a sensor evaluation.
    Sensor {
        /// Sensor identifier (ULID).
        sensor_id: String,
        /// Evaluation identifier.
        eval_id: String,
    },
    /// Triggered by a backfill chunk.
    Backfill {
        /// Backfill identifier (ULID).
        backfill_id: String,
        /// Chunk identifier.
        chunk_id: String,
    },
    /// Manual trigger.
    Manual {
        /// User who triggered the run.
        user_id: String,
        /// Request identifier for idempotency.
        request_id: String,
    },
}

/// Sensor status for state tracking.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum SensorStatus {
    /// Sensor is active and evaluating.
    Active,
    /// Sensor is paused.
    Paused,
    /// Sensor is in error state.
    Error,
}

impl Default for SensorStatus {
    fn default() -> Self {
        Self::Active
    }
}

/// Computes a full SHA-256 hex digest for idempotency keys.
#[must_use]
pub fn sha256_hex(input: &str) -> String {
    use sha2::{Digest, Sha256};
    let mut hasher = Sha256::new();
    hasher.update(input.as_bytes());
    let result = hasher.finalize();
    hex::encode(result)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tick_status_serialization() {
        let triggered = TickStatus::Triggered;
        let json = serde_json::to_string(&triggered).unwrap();
        assert!(json.contains("triggered"));

        let skipped = TickStatus::Skipped {
            reason: "paused".into(),
        };
        let json = serde_json::to_string(&skipped).unwrap();
        assert!(json.contains("skipped"));
        assert!(json.contains("paused"));
    }

    #[test]
    fn test_trigger_source_serialization() {
        let push = TriggerSource::Push {
            message_id: "msg_123".into(),
        };
        let json = serde_json::to_string(&push).unwrap();
        assert!(json.contains("push"));
        assert!(json.contains("msg_123"));

        let poll = TriggerSource::Poll {
            poll_epoch: 1736935200,
        };
        let json = serde_json::to_string(&poll).unwrap();
        assert!(json.contains("poll"));
        assert!(json.contains("1736935200"));
    }

    #[test]
    fn test_sensor_eval_status_serialization() {
        let triggered = SensorEvalStatus::Triggered;
        let json = serde_json::to_string(&triggered).unwrap();
        assert!(json.contains(r#""status":"triggered""#));

        let error = SensorEvalStatus::Error {
            message: "boom".into(),
        };
        let json = serde_json::to_string(&error).unwrap();
        assert!(json.contains(r#""status":"error""#));
        assert!(json.contains(r#""message":"boom""#));
    }

    #[test]
    fn test_sha256_hex() {
        let hash1 = sha256_hex("test_input");
        let hash2 = sha256_hex("test_input");
        assert_eq!(hash1, hash2);
        assert_eq!(hash1.len(), 64); // Full SHA-256 hex digest

        let hash3 = sha256_hex("different_input");
        assert_ne!(hash1, hash3);
    }
}
