   297	#[instrument(skip_all, fields(request_id = %ctx.request_id, tenant = %ctx.tenant, workspace = %ctx.workspace, prefix = %path.prefix, namespace = %path.namespace))]
   298	async fn head_namespace(
   299	    Extension(ctx): Extension<IcebergRequestContext>,
   300	    State(state): State<IcebergState>,
   301	    Path(path): Path<NamespacePath>,
   302	) -> IcebergResult<Response> {
   303	    ensure_prefix(&path.prefix, &state.config)?;
   304	    let separator = state.config.namespace_separator_decoded();
   305	    let namespace_ident = parse_namespace(&path.namespace, &separator)?;
   306	    let namespace_name = join_namespace(&namespace_ident, &separator)?;
   307	
   308	    let storage = ctx.scoped_storage(Arc::clone(&state.storage))?;
   309	    let reader = CatalogReader::new(storage);
   310	
   311	    let exists = reader
   312	        .get_namespace(&namespace_name)
   313	        .await
   314	        .map_err(IcebergError::from)?
   315	        .is_some();
   316	
   317	    let status = if exists {
   318	        StatusCode::NO_CONTENT
   319	    } else {
   320	        StatusCode::NOT_FOUND
   321	    };
   322	
   323	    Response::builder()
   324	        .status(status)
   325	        .body(axum::body::Body::empty())
   326	        .map_err(|e| IcebergError::Internal {
   327	            message: format!("Failed to build response: {e}"),
   328	        })
   329	}
